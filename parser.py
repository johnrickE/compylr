#!/usr/bin/env python3

"""
Parser functionality.
"""

__author__ = 'johnrickE'


# Reserved grammar symbols
NIL = -2 # ε  terminal indicating an empty production
END = -1 # $  terminal indicating end-of-input
GOAL = 0 # S' non-terminal used to distinguish ACCEPT from REDUCE actions

# Parser actions
SHIFT = 0
REDUCE = 1
ACCEPT = 2
# GOTO is technically not a parser action, but is rather another table separate from the ACTION table.
# It is included here anyways for implementation-specific reasons.
GOTO = 3


class TerminalSet:
    """
    A set of terminals in a context-free grammar.
    """

    def __init__(self):
        """
        Constructs a new TerminalSet containing {$, ε}.
        """
        self.last = NIL # Last-added symbol.
    
    def add(self):
        """
        Adds a new terminal symbol to this set.

        :return The newly added symbol.
        """
        self.last -= 1
        return self.last
    
    def __contains__(self, symbol):
        return symbol >= self.last and symbol <= END

    def __len__(self):
        return -self.last


class NonTerminalSet:
    """
    A set of non-terminals in a context-free grammar.
    """

    def __init__(self):
        """
        Constructs a new NonTerminalSet containing {S'}.
        """
        self.last = GOAL # Last-added symbol.
    
    def add(self):
        """
        Adds a new non-terminal symbol to this set.

        :return The newly added symbol.
        """
        self.last += 1
        return self.last
    
    def __contains__(self, symbol):
        return symbol >= GOAL and symbol <= self.last
    
    def __len__(self):
        return 1 + self.last


class LexerError(Exception):
    pass


class ParserError(Exception):
    pass


class Parser:
    """
    A canonical LR parser.

    To create a Parser object from a context-free grammar, see the parsergen.ParserGenerator class.

    Reduction callbacks:

    This class allows users to traverse the parse tree as it is being constructed, via the use of
    reduction callbacks. A reduction callback is a function assigned to each production rule.
    When the parser reduces a string of symbols to a single non-terminal symbol under a certain
    production rule, the reduction callback for that rule gets called. The callback takes in a
    list of 'terms' that correspond to the symbols being reduced, and returns a term representing
    the new non-terminal (the LHS symbol of the production).

    If a symbol is a terminal, then the term corresponding to that symbol is the token value returned
    by the lexer. If a symbol is a non-terminal, then the term is whatever was returned by a reduction
    callback when that symbol was reduced.

    Tokenization:

    This class by itself does not handle lexical analysis of input. To convert the source into a stream
    of tokens, users must define a class that contains a method called 'lex', which returns the next
    token in the stream. A token is a tuple consisting of the terminal symbol as well as a token value
    derived from the source. Additionally, the lex method must return (END, None) if the end-of-stream
    is reached. An instance of this class can then be passed to the Parser object.
    """

    def __init__(self, table, reductions, lexer_factory, context_factory):
        """
        Constructs a new Parser object.

        :param table        An LR(1) parsing table. This should be generated by the parsergen.ParserGenerator class.
        :param reductions   A reduction lookup buffer. This This should be generated by the parsergen.ParserGenerator class.
        :lexer_factory      A lambda that wraps input in a 'lexer' class.
        :context_factory    A lambda that returns some user-defined data to be used in reduction callbacks.
        """
        self.table = table
        self.reductions = reductions
        self.lexer_factory = lexer_factory
        self.context_factory = context_factory
    
    def parse(self, source, user_data=None):
        """
        Parses the given input using the LR parsing algorithm.

        :param source       The input to parse.
        :param user_data    Optional user data used to create a reduction context.

        :return The result of the reduction callback for the goal production rule.
        """

        table = self.table
        reductions = self.reductions

        lexer = self.lexer_factory(source)
        context = self.context_factory(user_data)
        stack = [0]
        lexeme, token = lexer.lex()
        while True:
            position = (stack[-1], lexeme)
            if position not in table:
                raise ParserError('Invalid input')
            action, index = table[position]
            if action == SHIFT:
                stack.append(token)
                stack.append(index) # index = next state
                lexeme, token = lexer.lex()
            elif action == REDUCE:
                # Reduction info contains:
                # - LHS symbol of the production
                # - Number of terms in RHS of the production
                # - The reduction callback
                lhs, n, callback = reductions[index] # index = reduction info position
                terms = []
                for _ in range(0, n):
                    stack.pop()
                    terms.append(stack.pop())
                # Terms were pushed in left-to-right order and popped in
                # right-to-left order, so we reverse the list to get the original
                # order.
                terms.reverse()
                node = callback(terms, context)
                position = (stack[-1], lhs)
                if position not in table:
                    raise ParserError('Invalid table - GOTO entry not found')
                _, next_state = table[position]
                stack.append(node)
                stack.append(next_state)
            elif action == ACCEPT:
                _, _, callback = reductions[0]
                stack.pop()
                return callback([stack.pop()], context)
            else:
                raise ParserError('Invalid table - unknown action found')
